<!DOCTYPE html>
<meta charset="utf-8">

<link rel="stylesheet" href="http://code.jquery.com/ui/1.9.0/themes/base/jquery-ui.css" />
<script src="http://code.jquery.com/jquery-1.8.2.js"></script>
<script src="http://code.jquery.com/ui/1.9.0/jquery-ui.js"></script>

<style> /* set the CSS */

body { font: 12px Arial;}

path {
    stroke-width: 6;
    fill: none;
}

circle{
  fill: steelblue;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

#slider label {
    position: absolute;
    width: 20px;
    margin-left: -10px;
    text-align: center;
    margin-top: 20px;
}

#slider{
  width:50%;
  margin-left: 10%;
}

</style>
<body>

<div id="option">
    <select onchange="update(this.value)">
         <option value="electricity">Electricity</option>
         <option value="computer">Computer</option>
         <option value="classroom_good_condition">Classroom Good Condition</option>
         <option value="classroom_major_repair">Classroom Major Repair</option>
         <option value="classroom_minor_repair">Classroom Minor Repair</option>
         <option value="girls_toilet">Girls Toilet</option>
         <option value="common_or_boys_toilet">Common or Boys Toilet</option>
         <option value="drinking_water">Drinking Water</option>
         <option value="mdm">MDM</option>
         <option value="kitchen_shed">Kitchen Shed</option>
    </select>
</div>

<!-- load the d3.js library -->
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>

<script>

var temp,
    facility, // type of facility selected
    iyear = 2006, //initial year of timescale
    fyear = 2014, //final year of timescale
    graph_data = [], //It is the final sorted data to be rendered in the graph
    color_codes = ['#28ABE3', '#20DA9B', '#E8B81A', '#DB3340', '#7F7F7F'],
    selected_districts = ['AHMADNAGAR', 'AKOLA', 'JALNA', 'NAGPUR', 'PARBHANI'],
    selected_facility = 'electricity';

// Set the dimensions of the canvas / graph
var margin = {
        top: 100,
        right: 20,
        bottom: 30,
        left: 100
    },
    width = 600,
    height = 400;

// Parse the date / time
var parseDate = d3.time.format("%y").parse;

// Set the ranges
var x = d3.time.scale().range([0, width]);
var y = d3.scale.linear().range([height, 0]);

// Define the axes
var xAxis = d3.svg.axis().scale(x)
    .orient("bottom").ticks(5);

var yAxis = d3.svg.axis().scale(y)
    .orient("left").ticks(5);

// Define the line
var valueline = d3.svg.line()
    .x(function(d) {
        return x(d.date);
    })
    .y(function(d) {
        return y(d.value);
    });

// Adds the svg canvas
var svg = d3.select("body")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");

load(selected_districts, true); // initially loading the data for AHMADNAGAR when page is opened.

function load(district, make) {
    // Everytime an update need to be made to the graph, this function is called
    //  Takes facilities as `parameter` and name of district as `district` and updates the graph.
    // `make` set to true creates a new graph on the same chart, whereas when it is false, it updates the already existing graph
    d3_queue.queue()
        .defer(d3.csv, "data/facilities.csv")
        .await(analyze);

    function analyze(error, data) {
        if (error) throw error;
        temp = d3.nest()
            .key(function(d) {
                return d.facility;
            })
            .entries(data)
            .filter(function(d) {
                return (d.key == selected_facility);
            });

        graph_data = [];

        for (var j = 0; j < district.length; j++) {
            for (var i = 0; i < temp[0].values.length; i++) {
                if (temp[0].values[i].district_name == district[j]) {
                    //console.log(temp[0].values[i]);
                    var dummy = [];
                    if (2006 >= iyear && 2006 <= fyear) {
                        dummy.push({
                            date: '06',
                            value: Math.min(temp[0].values[i].year_2006, 100)
                        });
                    }
                    if (2007 >= iyear && 2007 <= fyear) {
                        dummy.push({
                            date: '07',
                            value: Math.min(temp[0].values[i].year_2007, 100)
                        });
                    }
                    if (2008 >= iyear && 2008 <= fyear) {
                        dummy.push({
                            date: '08',
                            value: Math.min(temp[0].values[i].year_2008, 100)
                        });
                    }
                    if (2009 >= iyear && 2009 <= fyear) {
                        dummy.push({
                            date: '09',
                            value: Math.min(temp[0].values[i].year_2009, 100)
                        });
                    }
                    if (2010 >= iyear && 2010 <= fyear) {
                        dummy.push({
                            date: '10',
                            value: Math.min(temp[0].values[i].year_2010, 100)
                        });
                    }
                    if (2011 >= iyear && 2011 <= fyear) {
                        dummy.push({
                            date: '11',
                            value: Math.min(temp[0].values[i].year_2011, 100)
                        });
                    }
                    if (2012 >= iyear && 2012 <= fyear) {
                        dummy.push({
                            date: '12',
                            value: Math.min(temp[0].values[i].year_2012, 100)
                        });
                    }
                    if (2013 >= iyear && 2013 <= fyear) {
                        dummy.push({
                            date: '13',
                            value: Math.min(temp[0].values[i].year_2013, 100)
                        });
                    }
                    if (2014 >= iyear && 2014 <= fyear) {
                        dummy.push({
                            date: '14',
                            value: Math.min(temp[0].values[i].year_2014, 100)
                        });
                    }
                    graph_data.push(dummy);
                    console.log(dummy);
                }
            }
        }

        //console.log(graph_data);
        if (make == true) {
            draw();
        } else {
            updateData();
        }
    }
}

function draw() {
    //called initially to declare and draw the graph.

    for (var i = 0; i < graph_data.length; i++) {
        graph_data[i].forEach(function(d) {
            d.date = parseDate(d.date);
            d.value = +d.value;
        });

        x.domain(d3.extent(graph_data[i], function(d) {
            return d.date;
        }));
        //y.domain([0, d3.max(data, function(d) { return d.value; })]);
        y.domain([0, 100]);

        // Add the valueline path.
        svg.append("path")
            .attr("class", 'line')
            .attr("id", 'line' + i)
            .attr("stroke", color_codes[i])
            .attr("d", valueline(graph_data[i]));
    }

    // Add the X Axis
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    // Add the Y Axis
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);
}


// ** Update data section (Called from the onclick)
function updateData() {
    // called to make transitions from the updated data
    var svg = d3.select("body").transition();

    for (var i = 0; i < graph_data.length; i++) {
        // Scale the range of the data again
        graph_data[i].forEach(function(d) {
            d.date = parseDate(d.date.toString());
            d.value = +d.value;
        });

        x.domain(d3.extent(graph_data[i], function(d) {
            return d.date;
        }));
        //y.domain([0, d3.max(data, function(d) { return d.value; })]);
        y.domain([0, 100]);

        // Make the changes
        svg.select("#line" + i.toString()) // change the line
            .duration(750)
            .attr("d", valueline(graph_data[i]));
    }

    svg.select(".x.axis") // change the x axis
        .duration(750)
        .call(xAxis);
    svg.select(".y.axis") // change the y axis
        .duration(750)
        .call(yAxis);
}

function update(facility) {
    //called when the option is changed.
    selected_facility = facility;
    load(selected_districts, false);
}

$("#slider").slider({
        range: true,
        min: 0,
        max: 8,
        values: [0, 8],
        slide: function(event, ui) {
            iyear = ui.values[0] + 2006;
            fyear = ui.values[1] + 2006;
            //console.log(iyear, fyear);
            load(selected_districts, false);
        }
    })
    .each(function() {
        var opt = $(this).data().uiSlider.options;
        var vals = opt.max - opt.min;
        for (var i = 0; i <= vals; i++) {
            var el = $('<label>' + (2006 + i) + '</label>').css('left', (i / vals * 100) + '%');
            $("#slider").append(el);
        }
    });
</script>

<div id="slider">

</body>
